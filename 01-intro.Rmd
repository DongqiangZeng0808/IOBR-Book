

# **How to install IOBR**

## `r if(knitr::is_html_output()) emo::ji("time")` Installing Dependency Packages

It is essential that you have R 3.6.3 or above already installed on your computer or server. IOBR is a pipeline that utilizes many other R packages that are currently available from CRAN, Bioconductor and GitHub.

```{r, warning=FALSE, message=FALSE, echo=TRUE, eval=FALSE}

if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
depens<-c('tibble', 'survival', 'survminer', 'limma', "DESeq2","devtools", 'limSolve', 'GSVA', 'e1071', 'preprocessCore', 
          "devtools", "tidyHeatmap", "caret", "glmnet", "ppcor",  "timeROC", "pracma", "factoextra", 
          "FactoMineR", "WGCNA", "patchwork", 'ggplot2', "biomaRt", 'ggpubr')
for(i in 1:length(depens)){
  depen<-depens[i]
  if (!requireNamespace(depen, quietly = TRUE))  BiocManager::install(depen,update = FALSE)
}
```

## `r if(knitr::is_html_output()) emo::ji("computer")` Install IOBR package

When the dependent environments are built, users are able to install IOBR from github by typing the following code into your R session:
```{r, message=FALSE}

if (!requireNamespace("IOBR", quietly = TRUE))  devtools::install_github("IOBR/IOBR")

library(IOBR)
```




## `r if(knitr::is_html_output()) emo::ji("zoom")` The main pipeline of IOBR

```{r echo=FALSE, flowchart, fig.cap='The main pipeline of IOBR',  fig.width= 8, fig.height = 5.5, fig.align='center'}
knitr::include_graphics(rep("./fig/IOBR-Package.png", 1))
```

## Main Functions

* <div style="color:green">**Data Preparation: data annotation and transformation**</div> 
    * `count2tpm()`: transform count data of RNA sequencing into TPM data.
    * `anno_eset()`: annotate the normalized genes expression matrix, including RNAseq and array (Affymetrix or Illumina).
    * `remove_duplicate_genes()`: remove the genes annotated with the duplicated symbol after normalization and retain only the symbol with highest expression level.
</br>

* <div style="color:green">**TME Deconvolution Module: integrate multiple algorithms to decode immune contexture**</div> 
    * `deconvo_tme()`: decode the TME infiltration with different deconvolution methodologies, based on bulk RNAseq, microarray or single cell RNAseq data.
    * `generateRef()`: generate a novel gene reference matrix for a specific feature such as infiltrating cell, through the  SVR and lsei algorithm.
</br>

* <div style="color:green">**Signature Module: calculate signature scores, estimate phenotype related signatures and corresponding genes, and evaluate signatures generated from single-cell RNA sequencing data **</div>
    * `calculate_sig_score()`: estimate the interested signatures enrolled in IOBR R package, which involves TME-associated, tumor-metabolism, and tumor-intrinsic signatures.
    * `feature_manipulation()`: manipulate features including the cell fraction and signatures generated from multi-omics data for latter analysis and model construction. Remove missing values, outliers and variables without significant variance.
    * `format_signatures()`: generate the object of `calculate_sig_score()`function, by inputting a data frame with signatures as column names of corresponding gene sets, and return a list contain the signature information for calculating multiple signature scores.
    * `format_msigdb()`: transform the signature gene sets data  with gmt format, which is not included in the signature collection and might be downloaded in the MSgiDB website, into the object of `calculate_sig_score()`function.
</br>
    
  * <div style="color:green">**Batch Analysis and Visualization: batch survival analysis and batch correlation analysis and other batch statistical analyses **</div>
    * `batch_surv`: batch survival analysis of multiple continuous variables including varied signature scores.
    * `subgroup_survival`: batch survival analysis of multiple categorized variables with different number of subgroups. 
    * `batch_cor()`: batch analysis of correlation between two continuous variables using Pearson correlation coefficient or Spearman's rank correlation coefficient .
    * `batch_wilcoxon()`: conduct batch wilcoxon analyses of binary variables.
    * `batch_pcc()`: batch analyses of Partial Correlation coefficient(PCC) between continuous variables  and minimize the interference derived from confounding factors.
    * `iobr_cor_plot()`: visualization of batch correlation analysis of signatures from 'sig_group'. Visualize the correlation between signature or phenotype with  expression of gene sets  in target signature is also supported.
    * `cell_bar_plot()`: batch visualization of TME cell fraction, supporting input of deconvolution results from 'CIBERSORT', 'EPIC' and 'quanTIseq' methodologies to further compare the TME cell distributions within one sample or among different samples. 
</br>

* <div style="color:green">**Signature Associated Mutation Module: identify and analyze mutations relevant to targeted signatures**</div>
    * `make_mut_matrix()`: transform the mutation data with MAF format(contain the columns of gene ID and the corresponding gene alterations which including SNP, indel and frameshift) into a mutation matrix in a suitable manner for further investigating signature relevant mutations.
    * `find_mutations()`: identify mutations associated with a distinct phenotype or signature.
</br>

* <div style="color:green">**Model Construction Module: feature selection and fast model construct to predict clinical phenotype**</div>
    * `BinomialModel()`: select features and construct a model to predict a binary phenotype.
    * `PrognosticMode()`: select features and construct a model to predict clinical survial outcome.
</br>



# **RNA Data preprocessing**
## Loading packages

Load the IOBR package in your R session after the installation is complete:
  ```{r, eval=TRUE, warning=FALSE, message=FALSE}
library(IOBR)
library(tidyverse)
library(clusterProfiler)
```

## Downloading data for example
Obtaining data set from GEO [Gastric cancer: GSE62254](https://pubmed.ncbi.nlm.nih.gov/25894828/) using `GEOquery` R package.
```{r,message=FALSE,warning=FALSE}
if (!requireNamespace("GEOquery", quietly = TRUE))  BiocManager::install("GEOquery")
library("GEOquery")
# NOTE: This process may take a few minutes which depends on the internet connection speed. Please wait for its completion.
eset_geo<-getGEO(GEO     = "GSE62254", getGPL  = F, destdir = "./")
eset    <-eset_geo[[1]]
eset    <-exprs(eset)
eset[1:5,1:5]
```

## Gene Annotation

Annotation of genes in the expression matrix and removal of duplicate genes.
```{r,message=FALSE,warning=FALSE}
# Load the annotation file `anno_hug133plus2` in IOBR.
head(anno_hug133plus2)

```

```{r,message=FALSE,warning=FALSE}
# Load the annotation file `anno_grch38` in IOBR.
head(anno_grch38)

```

```{r,message=FALSE,warning=FALSE}
# Load the annotation file `anno_gc_vm32` in IOBR for mouse RNAseq data
head(anno_gc_vm32)

```


### For Array data: HGU133PLUS-2 (Affaymetrix)
```{r,message=FALSE,warning=FALSE}

# Conduct gene annotation using `anno_hug133plus2` file; If identical gene symbols exists, these genes would be ordered by the mean expression levels. The gene symbol with highest mean expression level is selected and remove others. 

eset<-anno_eset(eset       = eset,
                annotation = anno_hug133plus2,
                symbol     = "symbol",
                probe      = "probe_id",
                method     = "mean")
eset[1:5, 1:3]
```

### For RNAseq data

Download RNAseq data using UCSCXenaTools
```{r, echo=FALSE, eval=FALSE}
if (!requireNamespace("UCSCXenaTools", quietly = TRUE))   BiocManager::install("UCSCXenaTools")
library(UCSCXenaTools)
# NOTE: This process may take a few minutes which depends on the internet connection speed. Please wait for its completion.
eset_stad<-XenaGenerate(subset = XenaCohorts =="GDC TCGA Stomach Cancer (STAD)") %>% 
  XenaFilter(filterDatasets    = "TCGA-STAD.htseq_counts.tsv") %>% 
  XenaQuery() %>%
  XenaDownload() %>% 
  XenaPrepare()
eset_stad[1:5, 1:3]
```

Transform gene expression matrix into TPM format, and conduct subsequent annotation. 
```{r, echo=FALSE, eval=FALSE}

# Remove the version numbers in Ensembl ID.
eset_stad$Ensembl_ID<-substring(eset_stad$Ensembl_ID, 1, 15)
eset_stad<-column_to_rownames(eset_stad, var = "Ensembl_ID")

# Revert back to original format because the data from UCSC was log2(x+1)transformed.
eset_stad<-(2^eset_stad)+1

eset_stad<-count2tpm(countMat = eset_stad, idType = "Ensembl", org="hsa", source = "local" )

eset_stad[1:5,1:5]
```

## Identifying outlier samples

Take ACRG microarray data for example
```{r, message = F, warning = F,  fig.width= 7, fig.height=7, fig.align='center'}

# source("E:/18-Github/Organization/IOBR/R/find_outlier_samples.R")
res <- find_outlier_samples(eset = eset, project = "ACRG", show_plot = TRUE)
eset1 <- eset[, !colnames(eset)%in%res]
```

## PCA analysis of molecular subtypes

```{r, message = F, warning = F, fig.width= 7.6, fig.height=7, fig.align='center'}
data("pdata_acrg")
res<- iobr_pca(data       = eset1,
              is.matrix   = TRUE,
              scale       = TRUE,
              is.log      = FALSE,
              pdata       = pdata_acrg, 
              id_pdata    = "ID", 
              group       = "Subtype",
              geom.ind    = "point", 
              cols        = "normal",
              palette     = "jama", 
              repel       = FALSE,
              ncp         = 5,
              axes        = c(1, 2),
              addEllipses = TRUE)
res
```


## Batch effect correction

Obtaining another data set from GEO [Gastric cancer: GSE57303](https://www.ncbi.nlm.nih.gov/pubmed/24935174/) using `GEOquery` R package.
```{r,message=FALSE,warning=FALSE}
# NOTE: This process may take a few minutes which depends on the internet connection speed. Please wait for its completion.
eset_geo<-getGEO(GEO     = "GSE57303", getGPL  = F, destdir = "./")
eset2    <-eset_geo[[1]]
eset2    <-exprs(eset2)
eset2[1:5,1:5]
```

Annotation of genes in the expression matrix and removal of duplicate genes.
```{r,message=FALSE,warning=FALSE}
eset2<-anno_eset(eset       = eset2,
                 annotation = anno_hug133plus2,
                 symbol     = "symbol",
                 probe      = "probe_id",
                 method     = "mean")
eset2[1:5, 1:5]
```


```{r, message=FALSE, fig.width= 11, fig.height = 5, fig.align='center'}
eset_com <- remove_batcheffect( eset1       = eset1,  
                                eset2       = eset2,   
                                eset3       = NULL,
                                id_type     = "symbol",
                                data_type   = "array", 
                                cols        = "normal", 
                                palette     = "jama", 
                                log2        = TRUE, 
                                check_eset  = TRUE,
                                adjust_eset = TRUE,
                                repel       = FALSE,
                                path        = "result")
dim(eset_com)
```

待补充-RNAseq的批次校正：count, combat-seq

## References

Yuqing Zhang and others, ComBat-seq: batch effect adjustment for RNA-seq count data, NAR Genomics and Bioinformatics, Volume 2, Issue 3, September 2020, lqaa078, https://doi.org/10.1093/nargab/lqaa078

Leek, J. T., Johnson, W. E., Parker, H. S., Jaffe, A. E., & Storey, J. D. (2012). The sva package for removing batch effects and other unwanted variation in high-throughput experiments. Bioinformatics, 28(6), 882-883.


# **Tumor ecosystem analysis**
## Determine TME subtype of gastric cancer using TMEclassifier
加载TME分类器R包[TMEclassifier](https://github.com/LiaoWJLab/TMEclassifier)
```{r, message=FALSE}

library(TMEclassifier)
tme <- tme_classifier(eset = eset1, scale = TRUE)
table(tme$TMEcluster)
head(tme)
```

```{r}
table(tme$TMEcluster)
head(tme)
```

## DEG analysis
选择IA和IE分型进行差异分析

```{r}
pdata <- tme[!tme$TMEcluster=="IS", ]
deg  <-   iobr_deg(eset         = eset,
                   annoation    = NULL,
                   pdata        = pdata,
                   group_id     = "TMEcluster",
                   pdata_id     = "ID",
                   array        = TRUE,
                   method       = "limma",
                   contrast     = c("deg_group","IA","IE"),
                   path         = NULL,
                   padj_cutoff  = 0.01,
                   logfc_cutoff = 0.5)
```


## GSEA analysis of DEGs

选择IOBR的signature collection
```{r}
head(deg)

sig_list <- signature_collection[c("TMEscoreB_CIR", "TMEscoreA_CIR", "DNA_replication", "Base_excision_repair",
                                   "Pan_F_TBRs", "TGFb.myCAF", "Ferroptosis", "TLS_Nature", "Glycolysis")]
sig_list
```
结果有报错，寻找原因中！！！


## DEG analysis
使用`find_markers_in_bulk`寻找TME分型相关的差异基因

```{r, message = F, warning = F}

library(Seurat)
res <- find_markers_in_bulk(pdata      = tme, 
                            eset       = eset, 
                            group      = "TMEcluster", 
                            nfeatures  = 2000, 
                            top_n      = 20, 
                            thresh.use = 0.15, 
                            only.pos   = TRUE, 
                            min.pct    = 0.10)
top15 <-  res$top_markers %>% dplyr:: group_by(cluster) %>%  dplyr::top_n(15, avg_log2FC)
top15$gene
```

使用`Seurat`的`DoHeatmap`进行热图的可视化
```{r,fig.show= 'hide',message=FALSE}
#定义分型对应的颜色
cols <- c('#2692a4','#fc0d3a','#ffbe0b')
p1 <- DoHeatmap(res$sce, top15$gene, group.colors = cols )+
  scale_fill_gradientn(colours = rev(colorRampPalette(RColorBrewer::brewer.pal(11,"RdBu"))(256)))

```

提取表达矩阵中的变量与TME分型数据进行合并
```{r,fig.show= 'hide',message=FALSE}

input <- combine_pd_eset(eset = eset, pdata = tme, feas = top15$gene, scale = T)

p2 <- sig_box(input, variable = "TMEcluster", signature = "IFNG", jitter = TRUE,
              cols =  cols, show_pvalue = TRUE, size_of_pvalue = 4)

p3 <- sig_box(input, variable = "TMEcluster", signature = "IL1A",  
              jitter = TRUE, cols =  cols, show_pvalue = TRUE, size_of_pvalue = 4)
```

合并以上获得的结果图
```{r, fig.width= 12, fig.height=9, message = F, warning = F}

if (!requireNamespace("patchwork", quietly = TRUE))   install.packages("patchwork")
library(patchwork)
p <- (p1|p2/p3) + plot_layout(widths = c(2.3,1))
p + plot_annotation(tag_levels = 'A')
```


## Identifying signatures associated with TME clusters

Calculate TME associated signatures-(through PCA method).
```{r, message = F, warning = F}
sig_tme<-calculate_sig_score(pdata           = NULL,
                             eset            = eset,
                             signature       = signature_collection,
                             method          = "pca",
                             mini_gene_count = 2)
sig_tme <- t(column_to_rownames(sig_tme, var = "ID"))
sig_tme[1:5, 1:3]
```

寻找与TMEcluster相关的特征变量
```{r, message = F, warning = F}
res <- find_markers_in_bulk(pdata = tme, eset = sig_tme, group = "TMEcluster", nfeatures = 1000, top_n = 20, min.pct = 0.10)

top15 <-  res$top_markers %>% dplyr:: group_by(cluster) %>%  dplyr::top_n(15, avg_log2FC)

p1 <- DoHeatmap(res$sce, top15$gene, group.colors = cols)+
  scale_fill_gradientn(colours = rev(colorRampPalette(RColorBrewer::brewer.pal(11,"RdBu"))(256)))
```

可视化结果：选择特征变量
```{r,fig.show= 'hide', message=FALSE}
top15$gene  <- gsub(top15$gene, pattern = "\\-", replacement = "\\_")
input <- combine_pd_eset(eset = sig_tme, pdata = tme, feas = top15$gene, scale = T)

p2 <- sig_box(input, variable = "TMEcluster", signature = "IFNG_signature_Ayers_et_al", jitter = TRUE,
              cols =  cols, show_pvalue = TRUE, size_of_pvalue = 4, size_of_font = 6)

p3 <- sig_box(input, variable = "TMEcluster", signature = "Neutrophils_Bindea_et_al",  
              jitter = TRUE, cols =  cols, show_pvalue = TRUE, size_of_pvalue = 4, size_of_font = 6)
```


```{r, fig.width= 12, fig.height=9}
p <- (p1|p2/p3) + plot_layout(widths = c(2.3,1))
p + plot_annotation(tag_levels = 'A')
```


```{r, fig.width= 5, fig.height=8}
library(survminer)
data(pdata_acrg, package = "IOBR")
input <- merge(pdata_acrg, input, by = "ID")
p1<-surv_group(input_pdata       = input,
               target_group      = "TMEcluster",
               ID                = "ID",
               reference_group   = "High",
               project           = "ACRG",
               cols              = cols, 
               time              = "OS_time",
               status            = "OS_status",
               time_type         = "month",
               save_path         = "result")
p1
```

```{r,fig.show= 'hide',message=FALSE}
p1<- percent_bar_plot(input, x = "TMEcluster" , y = "Subtype", palette = "jama")
p2<- percent_bar_plot(input, x = "TMEcluster" , y = "Lauren", palette = "jama")
p3<- percent_bar_plot(input, x = "TMEcluster" , y = "TMEscore_binary", palette = "jama")
```

```{r,fig.width= 12, fig.height=8}
p1|p2|p3
```
